##  1.깃이란? 
파일이 바뀔때마다 스냅샷을 저장하여 효율성을 높임

working Directory: 실제 작업 공간
Staging Area(index) : 커밋하기 전 "저장할 변경 사항"에 대해 표시하는 영역
Repository (.git) : Git이 스냅샷을 영구적으로 저장하는 장소

로컬 저장소에 대하여
git init -> .git 폴더 생성
git status -> 파일 상태 추적
git diff -> 수정했으나 add(staging)하지 않은 변경 내용확인, --staged 를 붙여 스테이징 내용 확인 가능
git log -> 커밋 히스토리 조회, --oneline을 붙여 예쁘게 볼 수 있음
git commit --amend -> 마지막 커밋 메시지 수정 및 빠진 파일 추가 가능 -> push 하기전에 사용하기!
.gitignore -> 깃이 추적하면 안되는 보안 토큰등 파일 목록 관리

## 2.브랜치 만들기
- 브랜치: 특정 커밋을 가리키는 가벼운 포인터,, main을 오염시키지 않고 독립적인 작업 가능
- HEAD : 현재 내가 위치한 브랜치를 가리키는 특수한 포인터

## 3.Merge
1. Fast-forward: 목적지 브랜치가 가리키는 커밋이 현재 브랜치의 직접적인 조상일 때, 단순히 포인터만 앞으로 이동
2. 3 - way Merge: 브랜치 갈래가 나뉘었을때, 각 브랜치의 끝과 공통 조상을 합쳐 새로운 
   "Merge Commit"을 만듦
- Squash and Merge: 여러개의 커밋을 하나의 커밋으로 합쳐서 목적 브랜치에 병합, 자잘한 수정 기록을 숨기고 메인 히스토리를 깔끔하게 유지가능

## 4.GitHub(원격 저장소) 와 협업하기
리모트 브랜치 관리
- origin: 내 컴퓨터가 아닌 서버에 있는 원격 저장소의 별명
- 명령어
	- git push: 로컬 커밋으 원격으로 전송
	- git fetch: 원격의 최신 정보를 가져옴 (합치진 않음)
	- git pull: 원격 정보를 가져와서 현재 브랜치와 자동으로 합침 (fetch + merge)
    - git switch 브랜치 -이동
	- git checkout 브랜치 -이동
	- git checkout -b 새로운 브랜치

- PR:
	- 리뷰하고 메인에 합치기 전에 요청하는 문서
	- 무엇을? 왜? 검증하고, 합의하는 과정
	- 목적이 하나여야하며, 설명과 테스트 방법이 포함되어야함

## 5.Merge Conflict 해결
- 발생 원인: 같은 파일의 같은 부분을 서로 다르게 수정하고 합치려 할 때 발생
- 해결흐름:
	- 충돌 발생 알림 확인
	- 에디터에서 ``<<<< HEAD``, ``======``, ``>>>>>>>>`` 표시 확인
	- 남길 코드를 선택하고 수동으로 수정
	- 수정 완료 후 git add, git commit 으로 마무리

**Commit 단위:** 기능 단위로 쪼개서 커밋하기! 나중에 문제 생겼을때 되돌리기 수월
**PR전 셀프리뷰**: Files changed 탭에서 짠 코드 읽어보기

## 6.실수와 싸우기

**Reset vs Revert
- Reset (과거를 지우고 이동) : 특정 커밋으로 시간을 되돌림
	-  --soft: 작업 내용은 유지하되 커밋만 취소
	-  --mixed: (기본) add(staging)까지 취소
	-  --hard: 작업 내용까지 삭제. **(이미 Push 한 커밋엔 절대 사용금지)
- Revert (실수를 인정하고 반대 커밋생성) : 
	- 기존 히스토리는 유지, 특정 커밋의 변경 사항만 취소하는 새로운 커밋 생성, 협업 중일때 안전하게 되돌리기 가능
- Stash (잠깐 치우기)
	- 작업 중 급하게 다른 브랜치로 넘어가야하는데, 커밋하기 애매할때 사용
	- 명령어:
		- git stash: 현재 작업을 임시 저장소에 저장하고 워킹 디렉토리를 깨끗하게 만듬
		- git stash pop: 가장 최근 저장한 작업을 다시 꺼내오기

## 7.히스토리 관리 전략
- Rebase: 깔끔한 히스토리 만들기
	- Merge와의 차이: 머지는 두 줄기의 히스토리를 합치는 커밋을 남기지만
	  리베이스는 내 작업의 기준점을 최신 커밋으로 재설정하여 히스토리를 한줄로 만듬
	  선형적인 기록 유지
	- 원격 저장소에 Push 된 커밋은 Rebase하지말자!!!!!!! 히스토리 꼬인다
- Squash Merge: 병합하는 시점에 모든 커밋을 하나로 뭉침 (GitHub PR 머지 추천 방식)

## 8.외부 프로젝트 관리
- Submodule : 다른 저장소를 내 프로젝트의 특정 폴더에 링크로 연결, 버전 고정이 정확하지만 업데이트 과정이 다소 번거로움
- Subtree: 다른 저장소의 코드를 내 프로젝트 안으로 복사해서 통합, 사용이 쉽고 별도의 설정 없이 clone 기능만으로 코드가 따라옴

## 9.GitHub Actions를 이용한 CI/CD

CI/CD? 
- CI : 코드 변경시마다 자동으로 빌드와 테스트를 실행하여 품질 검증
- CD: 검증된 코드를 실제 서버에 자동으로 배포

GitHub Actions 주요 구성 요소:
- workflow : 자동화된 전체 프로세스 (``.github/workflows/*.yml)``파일
- Event(Trigger): 언제 실행할지 결정 (예: push or pullRequest)
- Jobs & Steps: 실행할 작업 단위와 그 안의 세부 명령어 세트
- Runner : 작업이 실행되는 가상 머신 (우분투 등)
- Secrets : API 키, 비밀번호 등 보안 데이터를 안전하게 저장하는 변수

**CD 흐름 예시**
`코드 Push` → `빌드/테스트(CI)` → `컨테이너 이미지 생성` → `이미지 레지스트리 업로드` → `클라우드 서버 배포(CD)`

## 10. Fork 기반 협업 (오픈소스 방식)

- **Upstream**: 원본 저장소.

- **Origin**: 원본을 내 계정으로 복사(Fork)해온 내 원격 저장소.

- **흐름**:
    
    1. 원본 저장소를 **Fork** 함.
        
    2. 내 원격 저장소를 **Clone** 함.
        
    3. 작업 후 내 원격 저장소(Origin)에 **Push**.
        
    4. 원본 저장소(Upstream)로 **Pull Request** 요청.
        

- **Secrets 관리**: 배포 자동화 시 클라우드 인증 정보를 절대 코드에 넣지 말기!!
  .반드시 `GitHub Secrets`를 사용

- **CI 실패 시**: CI 테스트가 실패하면 PR을 절대 머지하지 않기