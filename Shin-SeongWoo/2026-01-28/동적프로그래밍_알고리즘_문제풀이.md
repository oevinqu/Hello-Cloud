# 알고리즘 문제 풀이 기록

### 문제 1

* **플랫폼 / 문제명**: 구름 LLM DeepDive 알고리즘 미션 강좌 / 구슬 게임
* **분류**: 동적 프로그래밍(DP)

### 핵심 아이디어 및 접근 방식

격자 형태에서 특정 지점까지 도달하는 경로의 수를 구하는 문제로, 이전에 풀었던 경로 DP 문제가 떠올랐다.
어떤 칸에 도달하는 경우의 수는 이전에 도달할 수 있는 칸들의 경우의 수를 더해서 구할 수 있다고 판단해 DP로 접근했다.

이 문제에서는 이동 방향에 제약이 있고, 방문할 수 없는 칸이 존재하기 때문에
각 칸으로 이동 가능한 경우만 골라서 상태 전이를 구성하는 것이 핵심이라고 생각했다.

* `dp[i][j]`를 해당 칸에 도달하는 경우의 수로 정의했다.
* 이동 가능한 방향과 막힌 칸 여부를 점화식에 그대로 반영했다.

### 배운 점 및 느낀 점

경로 DP처럼 경우의 수를 세는 문제에서는 습관적으로 MOD 연산을 적용했는데,
이번 문제에서는 MOD로 나누라는 조건이 없어서 오히려 나누면 오답이 되었다.

문제를 풀기 전에 조건을 제대로 확인하지 않고 기존 풀이 패턴을 그대로 적용하면
이런 실수를 할 수 있다는 점을 체감했다.

* 경우의 수 문제라도 MOD 조건이 있는지 반드시 문제에서 명시된 내용만 기준으로 삼아야 한다.
* 익숙한 패턴일수록 문제 조건을 한 번 더 확인하는 습관이 필요하다고 느꼈다.


<details>
<summary><b>소스 코드 보기</b></summary>

```python

# -*- coding: utf-8 -*-
# UTF-8 encoding when using korean
import sys

input = sys.stdin.readline

N, M, K = map(int, input().split())

dp = [[0]*(N+M+1) for _ in range(K + 1)]
dp[0][N] = 1

for i in range(K):
    for j in range(1, N + M):
        dp[i + 1][j - 1] += dp[i][j]
        dp[i + 1][j] += dp[i][j]
        dp[i + 1][j + 1] += dp[i][j]
        
result = 0
for i in range(1, K + 1):
    result += dp[i][0] + dp[i][N + M]
    
print(result)

```

</details>

---
