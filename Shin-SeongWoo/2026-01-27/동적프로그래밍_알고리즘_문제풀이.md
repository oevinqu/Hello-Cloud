# 알고리즘 문제 풀이 기록

### 문제 1

* **플랫폼 / 문제명**: 구름 LLM DeepDive 알고리즘 미션 강좌 / 피보나치 수열
* **분류**: 동적 프로그래밍(DP)

### 핵심 아이디어 및 접근 방식

다음 항을 구하기 위해서는 이전 항의 값이 필요하다는 점에서 DP 문제라고 판단했다. 또한 수열이 순서대로 정의되기 때문에, 계산 역시 앞에서부터 차례대로 진행해야 한다.

* 현재 항은 바로 이전 두 항의 값으로 결정된다.
* 계산 순서가 고정되어 있어 인덱스로 접근 가능한 자료구조가 적합하다.
* 반복문을 활용한 바텀업 방식이 자연스럽다고 판단했다.

### 배운 점 및 느낀 점

처음에는 탑다운 방식(재귀)을 먼저 떠올려 구현했으나, 입력 크기가 커지면서 스택 오버플로우가 발생했다. 이후 배열을 활용한 바텀업 방식으로 전환했다.

로직 자체에는 문제가 없다고 생각했지만, 값이 커지면서 정수 오버플로우가 발생했고, 이를 통해 문제 조건에 맞는 모듈러 연산의 중요성을 다시 인식했다. 다음에는 탑다운 방식 + 메모이제이션으로도 한 번 더 풀어보고 비교해보고 싶다.

* 재귀는 직관적이지만 입력 범위를 반드시 고려해야 한다.
* 문제에서 요구하는 출력 범위(모듈러 조건)를 초기에 확인하는 습관이 필요하다.

<details>
<summary><b>소스 코드 보기</b></summary>

```python

# -*- coding: utf-8 -*-
# UTF-8 encoding when using korean
import sys

input = sys.stdin.readline

N = int(input())

arr = [0] * N

arr[1] = 1

for i in range(2, N):
	arr[i] = (arr[i-1] + arr[i-2]) % (10**9 + 7)

print(arr[N-1])

```

</details>

---

### 문제 2

* **플랫폼 / 문제명**: 구름 LLM DeepDive 알고리즘 미션 강좌 / 동전 줍기 대회
* **분류**: 동적 프로그래밍 (DP)

### 핵심 아이디어

N개의 동전 중 연속된 구간을 선택했을 때 얻을 수 있는 최대 합을 구하는 문제였다. 반드시 연속되어야 한다는 조건을 보고, 최대 구간 합 문제라고 판단했다.

현재 위치까지의 최적해를 구하기 위해 이전까지의 누적 합을 활용해야 했고, 이 점에서 DP로 접근하는 것이 적절하다고 생각했다.

* 누적 합을 이용해 각 위치까지의 합을 계산한다.
* 이전까지의 최소 누적 합을 유지하며 최대 차이를 갱신한다.

### 배운 점

DP는 단순히 배열을 채우는 문제가 아니라, 이전 상태를 어떻게 정의하느냐가 핵심이라는 점을 다시 느꼈다. 같은 문제라도 누적 합, 상태 압축 등 다양한 방식으로 풀 수 있다는 점이 인상 깊었다.

* "이전 값이 현재 판단에 필요한가"를 기준으로 DP 여부를 판단하면 좋겠다.

<details>
<summary><b>소스 코드 보기</b></summary>

```python

# -*- coding: utf-8 -*-
# UTF-8 encoding when using korean
import sys

input = sys.stdin.readline

N = int(input())
C = list(map(int, input().split()))

result = 0
min_s = 0

arr = [0] * N
arr[0] = C[0]

for i in range(1,N):
	arr[i] = arr[i-1] + C[i]

for i in range(N):
	result = max(result, arr[i] - min_s)
	min_s = min(min_s, arr[i])
		
print(result)

```

</details>

---

### 문제 3

* **플랫폼 / 문제명**: 구름 LLM DeepDive 알고리즘 미션 강좌 / 주사위 여행
* **분류**: 동적 프로그래밍 (DP)

### 핵심 아이디어

격자 형태에서 경로의 개수를 세는 문제로, 예전에 배웠던 경로 계산 방식이 떠올랐다. 특정 지점까지 도달하는 경우의 수는 이전 지점들의 경우의 수를 더해 구할 수 있다는 점에서 DP로 접근했다.

이 문제에서는 이동 방향에 제약이 있고, 특정 칸은 방문할 수 없다는 조건이 추가되어 있어 상태 전이 조건을 명확히 나누는 것이 중요하다고 느꼈다.

* 특정 칸에 도달할 수 있는 경우의 수를 DP 테이블로 관리한다.
* 이동 규칙과 제한 조건을 그대로 점화식에 반영한다.

### 배운 점

항상 단순한 직선 구조의 DP만 나오는 것이 아니라, 방향성과 조건이 결합된 형태로도 출제될 수 있다는 점을 체감했다. 또한 상수(MOD)를 미리 정의해두면 코드 가독성이 좋아진다는 점도 배웠다.

* 조건이 많을수록 상태 정의를 먼저 명확히 하는 것이 중요하다.

<details>
<summary><b>소스 코드 보기</b></summary>

```python

# -*- coding: utf-8 -*-
# UTF-8 encoding when using korean
import sys
input = sys.stdin.readline

MOD = 10**9 + 7

N, M, K = map(int, input().split())

rest = [[False]*(M+1) for _ in range(N+1)]

for _ in range(K):
	r, c = map(int, input().split())
	rest[r][c] = True

dp = [[0]*(M+1) for _ in range(N+1)]
dp[1][1] = 1

for r in range(1, N+1):
	for c in range(1, M+1):
		if dp[r][c] == 0:
			continue
		if rest[r][c]:
			continue
			
		for x in range(1, 7):
			nr = r + x
			nc = c + x
			
			if nr <= N and not rest[nr][c]:
				dp[nr][c] = (dp[nr][c] + dp[r][c]) % MOD
				
			if nc <= M and not rest[r][nc]:
				dp[r][nc] = (dp[r][nc] + dp[r][c]) % MOD
				
print(dp[N][M] % MOD)

```

</details>

---
