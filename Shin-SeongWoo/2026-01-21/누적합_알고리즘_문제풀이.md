# 알고리즘 문제 풀이 기록

### 문제 1

* **플랫폼 / 문제명**: 구름 LLM DeepDive 알고리즘 미션 강좌 / 구름랜드
* **분류**: 누적 합 (Prefix Sum)
* **핵심 아이디어**:
  배열의 누적 합 배열을 미리 만들어 두고
  구간 합을 `PS[R] - PS[L-1]` 형태로 O(1)에 계산
* **배운 점**:
  매 쿼리마다 합을 다시 구하면 시간 초과가 나기 쉽다
  누적 합은 **전처리로 시간 복잡도를 줄이는 대표적인 패턴**이다

<details>
<summary>소스 코드 보기</summary>

```python
# -*- coding: utf-8 -*-
# UTF-8 encoding when using korean
import sys

input = sys.stdin.readline

N = int(input())
F = list(map(int, input().split()))

PS = [0] * N
PS[0] = F[0]

for i in range(1, N):
    PS[i] = PS[i-1] + F[i]

Q = int(input())

for _ in range(Q):
    L, R = map(int, input().split())
    if L == 1:
        print(PS[R-1])
    else:
        print(PS[R-1] - PS[L-2])
```

</details>

---

### 문제 2

* **플랫폼 / 문제명**: 구름 LLM DeepDive 알고리즘 미션 강좌 / 도장 만들기
* **분류**: 누적 합 + 해시맵 (Counter)
* **핵심 아이디어**:
  문자열을 순회하면서 **문자 빈도 누적 상태를 저장**
  구간 [l, r]의 문자 빈도는
  `PS[r] - PS[l-1]` 형태의 Counter 차이로 계산
* **배운 점**:
숫자 배열뿐 아니라 딕셔너리(Counter)도 누적 합처럼 활용할 수 있다는 것을 배웠다.
누적 상태를 그대로 복사해 두면,
복잡한 문자열 쿼리도 단순한 연산으로 처리할 수 있었다.

<details>
<summary>소스 코드 보기</summary>

```python
# -*- coding: utf-8 -*-
# UTF-8 encoding when using korean

import sys
from collections import Counter
input = sys.stdin.readline

N, S = input().split()
N = int(N)
Q = int(input())

PS = []
s_dic = Counter()

for c in S.strip():
    s_dic[c] += 1
    PS.append(s_dic.copy())

for _ in range(Q):
    l, r, M, T = input().split()
    l, r, M = int(l), int(r), int(M)
    t_dic = Counter(T.strip())

    if l == 1:
        dic = PS[r-1]
    else:
        dic = Counter()
        for key in PS[r-1]:
            dic[key] = PS[r-1][key] - PS[l-2].get(key, 0)

    result = float('inf')
    for key in t_dic:
        result = min(result, dic.get(key, 0) // t_dic[key])

    print(result)
```

</details>

---
