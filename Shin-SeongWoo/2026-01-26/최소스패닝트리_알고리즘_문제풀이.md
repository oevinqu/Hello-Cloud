# 알고리즘 문제 풀이 기록

### 문제 1

* **플랫폼 / 문제명**: 구름 LLM DeepDive 알고리즘 미션 강좌 / 친구사이
* **분류**: 최소 신장 트리 (MST) / 프림(Prim) 알고리즘 / 우선순위 큐

### 핵심 아이디어

문제는 여러 사람(정점)을 친구 관계(간선)로 연결할 때,
**모든 사람을 연결하는 최소 비용**을 구하는 문제였다.

초기 입력으로 주어지는 `M`개의 친구 관계는 **비용이 0**이며,
추가로 `K`개의 관계는 각각 가중치를 가진 간선으로 주어진다.

즉, 이 문제는

> **모든 정점을 연결하는 최소 비용의 그래프**를 구하는
> **최소 신장 트리(MST)** 문제로 해석할 수 있다.

이를 위해 프림 알고리즘을 적용했다.

* 1번 정점을 시작으로 선택
* 현재 연결된 정점 집합에서
  아직 방문하지 않은 정점으로 가는 **가장 비용이 작은 간선**을 반복적으로 선택
* 모든 정점을 방문하면 MST 완성

만약 모든 정점을 방문하지 못했다면,
그래프가 연결되지 않은 것이므로 `-1`을 출력한다.

### 배운 점

* **비용이 0인 간선도 MST에서는 중요한 역할**을 한다는 점을 다시 확인했다.
* 프림 알고리즘은 다익스트라와 구조가 매우 유사하지만,
  **“최단 거리”가 아니라 “연결 비용”을 누적**한다는 점이 다르다.
* 마지막에 방문 여부를 한 번 더 체크해
  **그래프의 연결성 판단**까지 해줘야 한다는 점을 놓치지 않아야 한다.

다익스트라, BFS와 흐름이 비슷해 코드 구조를 이해하는 데는 어렵지 않았지만,
**왜 이 문제가 MST인지 먼저 판단하는 과정**이 중요하다는 것을 느꼈다.

<details>
<summary><b>소스 코드 보기</b></summary>

```python
# -*- coding: utf-8 -*-
# UTF-8 encoding when using korean
import sys
import heapq

input = sys.stdin.readline

N = int(input())
M = int(input())

graphs = [[] for _ in range(N+1)]
result = 0

for _ in range(M):
    a, b = map(int, input().split())
    graphs[a].append((b, 0))
    graphs[b].append((a, 0))

K = int(input())

for _ in range(K):
    u, v, w = map(int, input().split())
    graphs[u].append((v, w))
    graphs[v].append((u, w))

hq = [(0, 1)]
visited = [False] * (N + 1)

while hq:
    d, v = heapq.heappop(hq)

    if visited[v]:
        continue

    visited[v] = True
    result += d

    for nv, nd in graphs[v]:
        if not visited[nv]:
            heapq.heappush(hq, (nd, nv))

check = True
for i in range(1, N + 1):
    if not visited[i]:
        check = False

print(result if check else -1)
```

</details>

---

### 문제 2

* **플랫폼 / 문제명**: 구름 LLM DeepDive 알고리즘 미션 강좌 / 절전
* **분류**: 최소 신장 트리 (MST) / 프림(Prim) 알고리즘 / 그래프 최적화

### 핵심 아이디어

모든 건물을 연결하는 전력선이 주어지고,
각 전력선에는 유지 비용이 존재한다.

문제의 핵심은:

* 모든 건물을 연결한 상태는 유지하되
* **불필요한 전력선을 제거하여 절약할 수 있는 최대 비용**을 구하는 것

이를 그래프로 보면,

* 모든 간선을 유지했을 때의 비용 합 = `total`
* 최소 신장 트리(MST)를 구성했을 때의 비용 합 = `result`

이때 절약 가능한 최대 비용은 다음과 같다.

```
절약 비용 = total - result
```

따라서 이 문제는
**전체 간선 비용 합을 구한 뒤, MST 비용을 빼는 문제**로 변환할 수 있다.

프림 알고리즘을 사용해
정점 1번부터 시작하여 최소 비용 간선을 선택하며 MST를 구성했고,
문제 조건에 따라 **K개의 정점이 연결되면 탐색을 종료**했다.

### 배운 점

* “얼마를 절약할 수 있는가”라는 질문은
  **전체 비용 − 최소 유지 비용**으로 치환할 수 있다.
* MST 문제는 결과를 직접 출력하는 것뿐만 아니라,
  **다른 값과의 차이를 구하는 방식으로도 자주 활용**된다.
* 프림 알고리즘의 의사코드를 직접 떠올리며 구현해보니,
  이전보다 로직의 흐름이 더 자연스럽게 연결되었다.

다익스트라나 BFS와 구조가 유사해 접근은 수월했지만,
**반복해서 직접 구현해보며 로직을 떠올리는 연습이 더 필요**하다고 느꼈다.

<details>
<summary><b>소스 코드 보기</b></summary>

```python
# -*- coding: utf-8 -*-
# UTF-8 encoding when using korean
import sys
import heapq

input = sys.stdin.readline

N, M, K = map(int, input().split())

graphs = [[] for _ in range(N + 1)]

total = 0
result = 0
count = 0

for _ in range(M):
    a, b, c = map(int, input().split())
    graphs[a].append((b, c))
    graphs[b].append((a, c))
    total += c

hq = [(0, 1)]
visited = [False] * (N + 1)

while hq:
    d, v = heapq.heappop(hq)

    if visited[v]:
        continue

    visited[v] = True
    result += d
    count += 1

    if count == K:
        break

    for nv, nd in graphs[v]:
        if not visited[nv]:
            heapq.heappush(hq, (nd, nv))

print(total - result)
```

</details>

---