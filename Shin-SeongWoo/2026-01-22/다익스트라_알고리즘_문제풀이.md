# 알고리즘 문제 풀이 기록

### 문제 1

* **플랫폼 / 문제명**: 구름 LLM DeepDive 알고리즘 미션 강좌 / 이동 비용 구하기
* **분류**: 다익스트라 (Dijkstra) / 우선순위 큐

### 핵심 아이디어

  시작 정점 `S`에서 모든 정점까지의 최단 거리를 구하기 위해 **우선순위 큐(힙)** 를 사용하는 다익스트라 알고리즘을 적용했다.

  현재까지의 최단 거리가 가장 짧은 정점을 먼저 꺼내고, 인접 정점에 대해 `현재 거리 + 간선 가중치` 로 갱신을 시도한다.

  이미 더 짧은 경로가 기록되어 있다면 해당 경로는 무시하여 불필요한 연산을 줄였다.

### 배운 점

  단순 BFS로는 가중치가 있는 그래프의 최단 거리를 구할 수 없고, **다익스트라는 “가장 짧은 거리부터 확정해 나간다”는 점이 핵심**이라는 것을 다시 한 번 정리할 수 있었다.

  또한 우선순위 큐에서 꺼낸 값이 이미 갱신된 거리보다 크면 바로 건너뛰는 조건이 시간 복잡도 최적화에 매우 중요하다는 것을 확인했다.

  다익스트라의 템플릿 같은 문제여서 다시 풀어보면서 익숙해져봐야겠다.


<details>
<summary>소스 코드 보기</summary>

```python
# -*- coding: utf-8 -*-
# UTF-8 encoding when using korean
import sys
import heapq

input = sys.stdin.readline

N, M = map(int, input().split())
S = int(input())

graphs = [[] for _ in range(N+1)]

for _ in range(M):
    s, e, w = map(int, input().split())
    graphs[s].append((e, w))

INF = int(1e18)

def dijkstra(start):
    dist = [INF] * (N + 1)
    dist[start] = 0
    dist[0] = 0

    hq = []
    heapq.heappush(hq, (0, start))

    while hq:
        cur_dist, cur = heapq.heappop(hq)

        if cur_dist > dist[cur]:
            continue

        for nxt, w in graphs[cur]:
            new_dist = cur_dist + w

            if new_dist < dist[nxt]:
                dist[nxt] = new_dist
                heapq.heappush(hq, (new_dist, nxt))

    return dist

result_dist = dijkstra(S)

result = 0

for d in result_dist:
    if d == INF:
        result -= 1
    else:
        result += d

print(result)
```

</details>

---


### 문제 2

* **플랫폼 / 문제명**: 구름 LLM DeepDive 알고리즘 미션 강좌 / 단체 이동
* **분류**: 다익스트라 (Dijkstra) / 그래프 모델링


### 핵심 아이디어

문제에서 여러 명의 사람들이 이동하고, 통로마다 한 번에 지나갈 수 있는 인원 제한이 있다는 점 때문에
처음에는 **동시 이동을 시뮬레이션해야 하는 문제처럼 느껴졌다**.

하지만 조건을 정리해보면,

* 항상 **모든 사람이 함께 이동**
* 하나의 통로를 선택하면 **전원이 해당 통로를 모두 지난 후** 다음 선택
* 통로는 한 번 비용 1로 최대 `k`명까지 통과 가능

이라는 특징이 있다.

따라서 통로 하나를 지나는 데 필요한 실제 비용은
사람 수 `C`와 통로의 제한 인원 `k`에 의해 다음과 같이 결정된다.

```
통로 비용 = ceil(C / k)
```

즉, 이 문제는
**각 통로의 가중치를 `ceil(C / k)`로 재정의한 뒤,
S번 방에서 E번 방까지의 최단 거리를 구하는 문제**로 모델링할 수 있다.

이렇게 변환하면 사람의 이동이나 동시성을 직접 고려할 필요 없이
**다익스트라 알고리즘을 그대로 적용**할 수 있다.


### 배운 점

* 복잡해 보이는 조건도 **그래프의 가중치로 압축하면 단순한 최단 경로 문제로 바뀐다**.
* 다익스트라는 여러 경로를 동시에 탐색하는 것처럼 보이지만,
  실제로는 **가장 비용이 작은 경로부터 하나씩 확정**해 나간다.
* 문제를 그대로 구현하려 하기보다,
  **어떻게 모델링할지 먼저 고민하는 것이 중요**하다는 점을 다시 느꼈다.


<details>
<summary><b>소스 코드 보기</b></summary>

```python
# -*- coding: utf-8 -*-
# UTF-8 encoding when using korean
import sys
import heapq

input = sys.stdin.readline

N, M = map(int, input().split())
S, E, C = map(int, input().split())

graphs = [[] for _ in range(N + 1)]
INF = int(1e18)

for _ in range(M):
    a, b, k = map(int, input().split())
    graphs[a].append((b, k))
    graphs[b].append((a, k))

def dijkstra(start):
    dist = [INF] * (N + 1)
    dist[start] = 0

    hq = []
    heapq.heappush(hq, (0, start))

    while hq:
        cur_dist, cur = heapq.heappop(hq)

        if cur_dist > dist[cur]:
            continue

        for nxt, k in graphs[cur]:
            cost = (C + k - 1) // k
            new_dist = cur_dist + cost

            if new_dist < dist[nxt]:
                dist[nxt] = new_dist
                heapq.heappush(hq, (new_dist, nxt))

    return dist

result_dist = dijkstra(S)
print(result_dist[E] if result_dist[E] != INF else -1)
```

</details>

---


### 문제 3

* **플랫폼 / 문제명**: 구름 LLM DeepDive 알고리즘 미션 강좌 / 신호 전달
* **분류**: 다익스트라 (Dijkstra) / 상태 확장 그래프 (방향 포함)

### 핵심 아이디어

격자에서 본사 `S`부터 지사 `E`까지 신호를 전달하는 데 걸리는 최소 시간을 구하는 문제이다.
각 칸은 여덟 방향으로 이동할 수 있지만, **모든 칸에서 자유롭게 방향을 바꿀 수 있는 것은 아니다**는 점이 핵심이었다.

문제를 자세히 읽어보면,

* `S`(본사), `.`(안테나)에서는
  → 신호를 받을 때마다 **여덟 방향 중 하나를 새로 선택**할 수 있다.
* 숫자 칸(`1~9`)에서는
  → **이전에 선택한 방향으로만 직진**할 수 있으며, 중간에 방향을 바꿀 수 없다.
* 각 칸의 저항력은
  → **해당 칸에서 다른 칸으로 이동할 때 드는 시간**을 의미한다.

즉, 단순히 `(행, 열)`만으로 상태를 정의하면 안 되고,
**현재 위치 + 진행 중인 방향**을 함께 고려해야 했다.

이를 위해 다익스트라의 상태를 다음과 같이 확장했다.

```
(r, c, dir)
```

* `r, c` : 현재 위치
* `dir` : 현재 진행 중인 방향 (0~7)

이에 따라 최단 거리 배열도 **3차원 배열**로 구성했다.

```
dist[r][c][dir]
```


### 배운 점

처음에는 모든 칸에서 8방향 이동이 가능하다고 단순하게 생각해
2차원 다익스트라로 접근했고, 그 결과 예제와 테스트 케이스가 계속 어긋났다.

문제를 다시 읽으면서
**“방향을 선택하는 시점이 제한되어 있다”** 는 점을 깨닫고 나서야
이 문제가 단순한 격자 최단 경로 문제가 아니라
**상태에 방향이 포함된 그래프 문제**라는 것을 이해하게 되었다.

특히,

* 같은 칸이라도 **어떤 방향으로 들어왔는지에 따라 이후 이동 가능성이 달라진다**
* 이럴 때는 `dist[r][c]` 가 아니라
  **`dist[r][c][상태]` 로 확장해야 한다**

는 점이 인상 깊었다.

3차원 배열을 사용하는 것이 처음에는 익숙하지 않았지만,
이 문제를 통해 “다익스트라는 꼭 노드만 관리하는 알고리즘이 아니라,
문제에서 필요한 상태 전체를 노드로 보면 된다” 는 감각을 조금 얻은 것 같다.


<details>
<summary><b>소스 코드 보기</b></summary>

```python

# -*- coding: utf-8 -*-
# UTF-8 encoding when using korean
import sys
import heapq

input = sys.stdin.readline

N, M = map(int, input().split())

board = [[0] * M for _ in range(N)]

d = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

INF = int(1e16)

start = []

for i in range(N):
	s = input().strip()
	for j in range(M):
		board[i][j] = s[j]

		if board[i][j] == 'S':
			start = [i, j]


def dijkstra(start):
	hq = []
	dist = [[[INF]*8 for _ in range(M)] for _ in range(N)]

	for dir in range(8):
		dist[start[0]][start[1]][dir] = 0
		heapq.heappush(hq, (0,start[0], start[1], dir))
	

	while hq:
		time, r, c, dir = heapq.heappop(hq)

		if time > dist[r][c][dir]:
			continue
		
		if board[r][c] == 'E':
			return time

		if board[r][c] == 'S' or board[r][c] == '.':
			for nd in range(8):
				nr, nc = r + d[nd][0], c + d[nd][1]
			
				if 0 <= nr < N and 0 <= nc < M and board[nr][nc] != '#':
					count = 1
					if board[r][c].isdigit():
						count = int(board[r][c])

					new_time = time + count

					if new_time < dist[nr][nc][nd]:
						dist[nr][nc][nd] = new_time
						heapq.heappush(hq, (new_time, nr, nc, nd))
		else:
				
			nr,  nc = r + d[dir][0], c + d[dir][1]

			if 0 <= nr < N and 0 <= nc < M and board[nr][nc] != '#':
				count = 1
				if board[r][c].isdigit():
					count = int(board[r][c])
					
				new_time = time + count

				if new_time < dist[nr][nc][dir]:
					dist[nr][nc][dir] = new_time
					heapq.heappush(hq, (new_time, nr, nc, dir))
				
	return -1

print(dijkstra(start))
```

</details>

---