# 알고리즘 문제 풀이 기록

### 문제 1

* **플랫폼 / 문제명**: 구름 LLM DeepDive 알고리즘 미션 강좌 / 보조배터리
* **분류**: 그리디
* **핵심 아이디어**:
  전용(X, Y)을 먼저 사용하고, 공용(XY)은 남은 전용 중 더 싼 쪽 선택
* **배운 점**:
  공용을 먼저 쓰면 이후 선택이 불리해질 수 있어
  우선순위 설정이 핵심이었다

<details>
<summary>소스 코드 보기</summary>

```python
# -*- coding: utf-8 -*-
import sys
input = sys.stdin.readline

X, Y, XY = map(int, input().split())
N = int(input())

x_list = []
y_list = []

count = 0
price = 0

for _ in range(N):
    c, t = map(int, input().split())
    if t == 0:
        x_list.append(c)
    else:
        y_list.append(c)

x_list.sort(reverse=True)
y_list.sort(reverse=True)

while X > 0 and x_list:
    price += x_list.pop()
    count += 1
    X -= 1

while Y > 0 and y_list:
    price += y_list.pop()
    count += 1
    Y -= 1

while XY > 0 and (x_list or y_list):
    if x_list and y_list:
        if x_list[-1] <= y_list[-1]:
            price += x_list.pop()
        else:
            price += y_list.pop()
    elif x_list:
        price += x_list.pop()
    else:
        price += y_list.pop()

    count += 1
    XY -= 1

print(count, price)
```

</details>

---

### 문제 2

* **플랫폼 / 문제명**: 구름 LLM DeepDive 알고리즘 미션 강좌 / 미사일 발사
* **분류**: 스위핑 / 누적 개수
* **핵심 아이디어**:
  작업을 시작·종료 이벤트로 나눠 시간순 정렬
* **배운 점**:
  시뮬레이션 대신 이벤트 기반으로 바꾸면 구조가 단순해진다

<details>
<summary>소스 코드 보기</summary>

```python
# -*- coding: utf-8 -*-
import sys
input = sys.stdin.readline

N = int(input())
events = []
total = 0

for _ in range(N):
    X, Y, T = map(int, input().split())
    dist = X**2 + Y**2
    total += 2 * dist
    events.append((T, 1))
    events.append((T + 2 * dist, -1))

events.sort()

current = 0
max_overlap = 0

for _, v in events:
    current += v
    max_overlap = max(max_overlap, current)

print(total - max_overlap)
```

</details>

---

### 문제 3

* **플랫폼 / 문제명**: 구름 LLM DeepDive 알고리즘 미션 강좌 / 초코 쿠키
* **분류**: 정렬 / 조건 검증
* **핵심 아이디어**:
  값 기준 정렬 후, 위치 변화로 조건 만족 여부 판단
* **배운 점**:
  정렬 결과 자체가 검증 수단이 될 수 있다

<details>
  <summary>소스 코드 보기</summary>

  ```python
  # -*- coding: utf-8 -*-
  import sys
  input = sys.stdin.readline

  N = int(input())
  A = list(map(int, input().split()))

  cookies = [(v, i + 1) for i, v in enumerate(A)]
  cookies.sort()

  possible = True
  for i, (v, _) in enumerate(cookies):
      if v - i <= 0:
          possible = False
          break

  if not possible:
      for i in range(1, N + 1):
          print(i, end=' ')
  else:
      for _, idx in cookies:
          print(idx, end=' ')
  ```

</details>

---
